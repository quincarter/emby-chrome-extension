import { readFileSync, writeFileSync, existsSync, mkdirSync, copyFileSync } from 'fs';
import { resolve, dirname, basename } from 'path';
import { fileURLToPath } from 'url';

const ROOT = resolve(dirname(fileURLToPath(import.meta.url)), '..');

const isLive = process.argv.includes('--live');
const RESULTS_PATH = resolve(
  ROOT,
  isLive ? 'playwright-report-live' : 'playwright-report',
  'results.json',
);
const OUTPUT_PATH = resolve(ROOT, 'e2e', 'README.md');
const SCREENSHOTS_DIR = resolve(ROOT, 'e2e', 'screenshots');

interface Attachment {
  name: string;
  contentType: string;
  path: string;
}

interface TestResultEntry {
  status: 'passed' | 'failed' | 'timedOut' | 'skipped' | 'interrupted';
  attachments?: Attachment[];
}

interface TestEntry {
  status: 'expected' | 'unexpected' | 'skipped' | 'flaky';
  results: TestResultEntry[];
}

interface TestCase {
  title: string;
  ok: boolean;
  tests: TestEntry[];
}

interface Suite {
  title: string;
  file: string;
  suites?: Suite[];
  specs?: TestCase[];
}

interface PlaywrightReport {
  suites: Suite[];
  stats: {
    expected: number;
    unexpected: number;
    skipped: number;
    flaky: number;
  };
}

const STATUS_ICONS: Record<string, string> = {
  expected: '‚úÖ',
  unexpected: '‚ùå',
  skipped: '‚è≠Ô∏è',
  flaky: '‚ö†Ô∏è',
};

const fixtureToSite: Record<string, string> = {
  imdb: 'IMDb',
  trakt: 'Trakt',
  google: 'Google Search',
  bing: 'Bing Search',
  justwatch: 'JustWatch',
  netflix: 'Netflix',
  amazon: 'Amazon',
};

const slugify = (text: string): string =>
  text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');

const collectTests = (
  suite: Suite,
): Array<{ group: string; title: string; status: string; screenshot: string | undefined }> => {
  const results: Array<{
    group: string;
    title: string;
    status: string;
    screenshot: string | undefined;
  }> = [];

  const walk = (s: Suite, parentTitle: string): void => {
    const groupTitle = parentTitle ? `${parentTitle} ‚Ä∫ ${s.title}` : s.title;

    if (s.specs) {
      for (const spec of s.specs) {
        const testEntry = spec.tests[0];
        const status = testEntry?.status ?? 'skipped';

        // Find screenshot attachment from the last result
        let screenshot: string | undefined;
        const lastResult = testEntry?.results?.[testEntry.results.length - 1];
        const attachment = lastResult?.attachments?.find(
          (a) =>
            (a.name === 'screenshot' || a.name === 'viewport') && a.contentType === 'image/png',
        );

        if (attachment?.path && existsSync(attachment.path)) {
          mkdirSync(SCREENSHOTS_DIR, { recursive: true });
          const slug = slugify(`${groupTitle}-${spec.title}`);
          const destName = `${slug}.png`;
          const destPath = resolve(SCREENSHOTS_DIR, destName);
          copyFileSync(attachment.path, destPath);
          screenshot = `screenshots/${destName}`;
        }

        results.push({ group: groupTitle, title: spec.title, status, screenshot });
      }
    }

    if (s.suites) {
      for (const child of s.suites) {
        walk(child, groupTitle);
      }
    }
  };

  walk(suite, '');
  return results;
};

const generate = (): void => {
  if (!existsSync(RESULTS_PATH)) {
    console.error(`No results file found at ${RESULTS_PATH}. Run tests first.`);
    process.exit(1);
  }

  const report: PlaywrightReport = JSON.parse(readFileSync(RESULTS_PATH, 'utf-8'));
  const { expected, unexpected, skipped, flaky } = report.stats;
  const total = expected + unexpected + skipped + flaky;
  const allPassed = unexpected === 0;

  const lines: string[] = [
    '# E2E Test Results',
    '',
    `> Auto-generated by \`scripts/generate-e2e-readme.ts\` from Playwright JSON results.`,
    '',
    `| Metric | Count |`,
    `| --- | --- |`,
    `| ${STATUS_ICONS.expected} Passed | ${expected} |`,
    `| ${STATUS_ICONS.unexpected} Failed | ${unexpected} |`,
    `| ${STATUS_ICONS.skipped} Skipped | ${skipped} |`,
    `| ${STATUS_ICONS.flaky} Flaky | ${flaky} |`,
    `| **Total** | **${total}** |`,
    '',
    `**Overall: ${allPassed ? '‚úÖ All tests passed' : '‚ùå Some tests failed'}**`,
    '',
    '---',
    '',
  ];

  for (const suite of report.suites) {
    const siteName =
      Object.entries(fixtureToSite).find(([key]) => suite.file.includes(key))?.[1] ?? suite.title;

    const tests = collectTests(suite);

    const passed = tests.filter((t) => t.status === 'expected').length;
    const failed = tests.filter((t) => t.status === 'unexpected').length;
    const siteIcon = failed > 0 ? '‚ùå' : '‚úÖ';

    lines.push(`## ${siteIcon} ${siteName} (${passed}/${tests.length})`);
    lines.push('');
    lines.push('| Status | Test |');
    lines.push('| --- | --- |');

    for (const t of tests) {
      const icon = STATUS_ICONS[t.status] ?? '‚ùì';
      lines.push(`| ${icon} | ${t.title} |`);
    }

    lines.push('');

    // Add screenshots in a collapsible section
    const testsWithScreenshots = tests.filter((t) => t.screenshot);
    if (testsWithScreenshots.length > 0) {
      lines.push('<details>');
      lines.push(`<summary>üì∏ Screenshots (${testsWithScreenshots.length})</summary>`);
      lines.push('');

      for (const t of testsWithScreenshots) {
        lines.push(`#### ${t.title}`);
        lines.push('');
        lines.push(`![${t.title}](${t.screenshot})`);
        lines.push('');
      }

      lines.push('</details>');
      lines.push('');
    }
  }

  lines.push('---');
  lines.push('');
  lines.push(
    '*Fixtures are located in `e2e/fixtures/`. Update them when site DOM structures change.*',
  );
  lines.push('');

  writeFileSync(OUTPUT_PATH, lines.join('\n'));
  console.log(`E2E README generated at ${OUTPUT_PATH}`);
};

generate();
